#contents

** RTコンポーネントフレームワーク

RTコンポーネントを作成するためのフレームワークです。

ロボットシステムを構成する要素をモジュール化するとき、様々な粒度でのモ
ジュール化が考えられます。たとえば、モータやセンサといった単機能のデバ
イス、移動ロボットやアームなど複合的なシステム、あるいは様々な処理を行
うアルゴリズムといった単位が考えられ、それらの階層的な集積によりシステ
ムが構築されます。RTミドルウエアでは、これらのRT機能要素の本質的なソフ
トウエア部分をコアロジックと呼びます。RTコンポーネントフレームワークは、
コアロジックに共通のインターフェースという皮を被せて、これらのモジュー
ルを統一的に扱うことができるようにするための仕組みです。

#ref(rtc_framework_ja.png,30%,center)
CENTER: ''RTコンポーネントフレームワークとコアロジック''

上図のように、ステレオビジョンのアルゴリズムをコンポーネント化する例を
考えると、アルゴリズムを実装したプログラムそのものはコアロジックに相当
します。適切なポートを設定したRTコンポーネントフレームワークを用意して
やり、ステレオビジョンアルゴリズムをこのフレームワークに実装してやるこ
とで、ステレオビジョンコンポーネントを作ることができます。このように、
コンポーネントフレームワークに基づきコンポーネント開発者がコアロジック
を実装し、システムに組み込むことができるようにしたモジュールをRTコンポー
ネントと呼びます。RTコンポーネントフレームワークは、共通インターフェー
スやその振る舞いをコンポーネント開発者や、コンポーネントを組合わせてシ
ステムを構築するインテグレータから隠蔽します。こうすることによって、コ
ンポーネント開発者はメインのロジックの実装に集中でき、インテグレータは
実装の詳細を気にすることなくシステム全体の設計に集中することができます。

** RTコンポーネントアーキテクチャ

RTシステムでは、低レベルのセンサ処理やアクチュエータ制御から、高レベル
の認識、判断、行動制御など、様々なレベルの処理を連携して行う必要があり
ます。低レベルの制御プログラムには、速度やリアルタイム性の要求を満たす
言語が求められる一方で、高レベルのプログラムには、抽象度や記述力の高い
言語が求められます。また、現在のRTシステムは、複数のCPUで構成されるケー
スが増えており、並列制御やネットワークを介した連携機能も必要です。

これらの機能要素をモジュール化するため、RTコンポーネントは、様々な粒度
でモジュール化が可能で、かつ、多様な言語、OS上で動作する、分散コンポー
ネント型のフレームワークを提供しています。

図にRTCの基本的なアーキテクチャを示します。RTCの主な機能としては以下の
ものがあります。

#ref(rtc_architecture_ja.png,30%,center)
CENTER: ''RTコンポーネントアーキテクチャ''

*** メタ情報取得

RTCはメタ情報 (RTC プロファイル) 取得のためのインターフェース (イントロ
スペクション機能) を持ちます。RTCプロファイルとは、コンポーネントの名前
や所有しているポートのプロファイルなど、コンポーネントの特性を表わす一
連の情報です。この機能は実行時の動的なシステム構成時に必要となります。

> イントロスペクション: 日本語で内省と訳される、オブジェクトやコンポーネントのメタ情報を取得する仕組みのこと. 定義は一定していないが、Java におけるリフレクションと類似の機能. OMG RTC仕様ではこの機能を introspection と定義している。

#ref(rtc_arch_introspection_ja.png,40%,center)
CENTER: ''メタ情報取得''

*** アクティビティ

コンポーネントの主たる機能を実行する部分。RTCの統一的管理のため、
Inactive (OFF状態)、Active (ON状態)、Error (エラー状態)といった共通の状
態遷移が決められています。RTC開発者は、主にそれぞれの状態やイベントに割
り当てられた関数 (コールバック関数) に実現したい機能を実装することで
RTCを作成します。

#ref(rtc_arch_activity_ja.png,40%,center)
CENTER: ''アクティビティと実行コンテキスト''

*** 実行コンテキスト

アクティビティの関数は、実行コンテキスト (Execution Context: EC) と呼ば
れるスレッドにより実行されます。ECは、RTCに対して動的にアタッチ・デタッチ
可能で、一つのECを複数のRTCに対してアタッチし、直列に同期的に実行させた
り、リアルタイム実行可能なEC と入れ替えることでRTCの実行をリアルタイム
化することも可能です。

*** データポート

連続的なデータの送受信を行うためのデータ指向ポート。入力ポート(InPort)
と出力ポート (OutPort) の2種類があり、同じデータ型同士なら、言語やOSが
異なっていても、ネットワークを介して接続・通信することができます。

#ref(rtc_arch_dataport_ja.png,40%,center)
CENTER: ''データポート''

*** サービスポート

コマンドレベルの詳細な機能の提供・利用を行う、ユーザ定義のプロバイダ
(提供(Provided)インターフェース)や、コンシューマ(要求 (Required) インター
フェース)を持たせることができるポート (外部に機能を提供するインターフェー
スを Provided Interface、外部の機能を要求・利用するインターフェースを
Required Interface と呼びます。)。データポート同様、言語、OSが異なって
いてもインターフェース型が同じなら接続し関数を呼び出すことができます。

#ref(rtc_arch_serviceport_ja.png,40%,center)
CENTER: ''データポート''

*** コンフィギュレーション

ユーザ定義のパラメータを、実行時に外部から変更するための機能。複数のパ
ラメータセットを持ち、それらを一斉に入れ替えることができます。パラメータ
を予め変更可能にしておくことで、RTCを様々なシステムで再利用可能にします。

#ref(rtc_arch_configuration_ja.png,40%,center)
CENTER: ''コンフィギュレーション''


一般に、RTシステムにおける低レベル部分では、サーボコントローラ等粒度が
細かくデータ指向の密結合なサブシステムが主体であり、判断や振る舞いを決
める高レベルの部分では、粒度の粗いサービス指向のサブシステムが主体とな
ります。RTCでは、こうした多様な粒度のモジュール化を共通のフレームワーク
で実現しているため、階層化フレームワークで問題となる、階層間の結合は問
題となりません。

異なる言語、およびOS上のRTC間の透過的連携は、分散オブジェクトミドルウエ
アの標準仕様である CORBA (Common Object Request Broker Architectur) を
利用することで実現されています。


 
